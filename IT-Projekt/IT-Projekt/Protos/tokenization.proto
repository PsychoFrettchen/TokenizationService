syntax = "proto3";

package tokenization.v1;

// ---- Sprachspezifische Optionen ----
// Legt fest, in welchem Namespace der generierte C#-Code landet.
option csharp_namespace = "em.Tokenization.V1";


// =============================================================
// ======================== ENUMS ===============================
// =============================================================

// Art des Tokenisierungsalgorithmus (hohes Abstraktionsniveau)
enum TokenType {
  TOKEN_TYPE_UNSPECIFIED = 0; // Nicht definiert / unbekannt.
  TOKEN_TYPE_RANDOM = 1;      // Zufällig generiertes Token, nicht rückführbar ohne Lookup.
  TOKEN_TYPE_FPE = 2;         // Format-preserving encryption – umkehrbar (z. B. FPE mit AES).
  TOKEN_TYPE_HMAC = 3;        // HMAC-basierte Tokenisierung (validierungsfähig, aber nicht umkehrbar ohne Speicherung).
  TOKEN_TYPE_HASH = 4;        // Einweg-Hash, nur zur Validierung geeignet.
  TOKEN_TYPE_ENCRYPTED = 5;   // Vollständige Verschlüsselung (z. B. AES-GCM).
}

// Optionaler semantischer Hinweis, welche Art von Daten tokenisiert wird.
enum DataClass {
  DATA_CLASS_UNSPECIFIED = 0;  // Keine Angabe / generisch.
  DATA_CLASS_GENERIC_TEXT = 1; // Freitext.
  DATA_CLASS_EMAIL = 2;        // E-Mail-Adresse.
  DATA_CLASS_PHONE = 3;        // Telefonnummer.
  DATA_CLASS_SSN = 4;          // Sozialversicherungsnummer.
  DATA_CLASS_CREDIT_CARD = 5;  // Kreditkartennummer.
  DATA_CLASS_IBAN = 6;         // IBAN / Kontonummer.
  DATA_CLASS_DATE = 7;         // Datum.
  DATA_CLASS_POSTAL_CODE = 8;  // Postleitzahl.
}

// Steuert, wie das Format bei aktivierter Formatbeibehaltung behandelt wird.
enum FormatMode {
  FORMAT_MODE_UNSPECIFIED = 0;
  // Behalte Länge und Zeichentypen bei (z. B. Zahlen bleiben Zahlen).
  FORMAT_MODE_PRESERVE_CLASS = 1;
  // Verwende eine feste Maske mit Literalzeichen (z. B. "XXXX-XXXX-XXXX-XXXX").
  // Platzhalterbedeutung: X = beliebig, 9 = Ziffer, A = Buchstabe.
  FORMAT_MODE_MASKED = 2;
}


// =============================================================
// ======================= NACHRICHTEN ==========================
// =============================================================

// Eingabefeld, das tokenisiert werden soll.
message FieldPayload {
  string field = 1;              // Logischer Feldname (z. B. "email", "card_number").
  string plaintext = 2;          // Klartextwert, der tokenisiert werden soll.
  DataClass data_class = 3;      // Optionale semantische Klassifizierung.
  bool preserve_format = 4;      // Format möglichst beibehalten (bei FPE).
  FormatMode format_mode = 5;    // Formatierungsmodus (siehe Enum).
  string format_mask = 6;        // Optionale Maske, falls format_mode == MASKED.
  map<string, string> attributes = 7; // Freie Zusatzattribute pro Feld.
}

// Ausgabe eines tokenisierten Feldes.
message TokenizedField {
  string field = 1;  // Name des Eingabefelds.
  string token = 2;  // Der erzeugte Tokenwert.
}

// Ausgabe eines detokenisierten Feldes.
message DetokenizedField {
  string field = 1;     // Name des Feldes.
  string plaintext = 2; // Der wiederhergestellte Klartext.
}

// Fehlerbeschreibung auf Feldebene (für Teil-Erfolge in Batch-Aufrufen).
message FieldError {
  string field = 1;   // Betroffenes Feld.
  int32 code = 2;     // Anwendungsspezifischer Fehlercode (z. B. 400xx oder 500xx).
  string message = 3; // Menschlich lesbare Erklärung.
}

// Kontextobjekt für Mandantenfähigkeit, Schlüsselwahl usw.
message Context {
  string tenant_id = 1;         // Mandanten-ID (zur Isolation mehrerer Kunden).
  string key_id = 2;            // Schlüsselkennung, die für diesen Vorgang verwendet werden soll.
  bytes tweak = 3;              // Optionaler Tweak für FPE (deterministische Variation pro Kontext).
  string purpose = 4;           // Zweck / Beschreibung (z. B. "billing", "anonymization").
  map<string, string> labels = 5; // Freie Schlüssel-Wert-Paare (z. B. env=prod, region=eu).
}


// =============================================================
// =================== UNARY-RPC-NACHRICHTEN ====================
// =============================================================

// Request für Tokenisierung mehrerer Felder.
message TokenizeRequest {
  repeated FieldPayload items = 1; // Mehrere Eingabefelder (Batch).
  TokenType token_type = 2;        // Gewünschter Algorithmustyp.
  Context context = 3;             // Kontext (Mandant, Schlüssel usw.).
}

// Antwort auf TokenizeRequest.
message TokenizeResponse {
  repeated TokenizedField items = 1; // Erfolgreich tokenisierte Felder.
  repeated FieldError errors = 2;    // Fehlgeschlagene Felder.
  string key_id = 3;                 // Tatsächlich verwendeter Schlüssel.
}

// Request für Detokenisierung.
message DetokenizeRequest {
  repeated TokenizedField items = 1; // Token(s), die rückgeführt werden sollen.
  Context context = 2;               // Kontext zur Auswahl des richtigen Schlüsselraums.
}

// Antwort auf DetokenizeRequest.
message DetokenizeResponse {
  repeated DetokenizedField items = 1; // Erfolgreich entschlüsselte Felder.
  repeated FieldError errors = 2;      // Per-Feld-Fehler.
  string key_id = 3;                   // Verwendeter Schlüssel.
}

// Anfrage zur Tokenvalidierung oder -inspektion.
message ValidateTokenRequest {
  string token = 1;   // Zu prüfender Token.
  Context context = 2;
}

// Antwort auf ValidateTokenRequest.
message ValidateTokenResponse {
  bool valid = 1;          // Ob der Token gültig ist.
  string field = 2;        // Zugehöriges Feld (falls bekannt).
  DataClass data_class = 3;// Ursprüngliche Datenklasse (falls bekannt).
  TokenType token_type = 4;// Ermittelter Token-Typ.
  string key_id = 5;       // Schlüsselkennung, falls ermittelbar.
}

// Anfrage zur Rotation oder Umschaltung des aktiven Schlüssels.
// Hierbei werden KEINE geheimen Schlüsselmaterialien übertragen,
// sondern nur Kennungen (Key IDs).
message RotateKeyRequest {
  string old_key_id = 1;      // Aktuell verwendeter Schlüssel (Referenz).
  string new_key_id = 2;      // Neuer aktiver Schlüssel.
  bool rewrap_only = 3;       // Falls true: nur interne Schlüssel rewrapen, keine Daten neu verschlüsseln.
  Context context = 4;        // Mandantenspezifischer Kontext.
}

// Antwort auf RotateKeyRequest.
message RotateKeyResponse {
  string active_key_id = 1;   // Jetzt aktiver Schlüssel.
}


// =============================================================
// ==================== STREAMING-SCHNITTSTELLEN ===============
// =============================================================

// Streaming-Tokenisierung ermöglicht große Datenmengen ohne Batch-Grenzen.

// Erste Nachricht im Stream (Initialisierung).
message StreamTokenizeInit {
  TokenType token_type = 1; // Algorithmus.
  Context context = 2;      // Kontext.
}

// Eingabedaten im Stream.
message StreamTokenizeIn {
  oneof payload {
    StreamTokenizeInit init = 1; // Muss vom Client zuerst gesendet werden.
    FieldPayload item = 2;       // Danach einzelne zu tokenisierende Felder.
  }
}

// Ausgabedaten im Stream (pro Item).
message StreamTokenizeOut {
  oneof result {
    TokenizedField item = 1; // Erfolgreiches Ergebnis für ein Eingabefeld.
    FieldError error = 2;    // Fehler für ein bestimmtes Eingabefeld.
  }
}


// =============================================================
// ======================== SERVICE ============================
// =============================================================

service TokenizationService {
  // Standard-Tokenisierung mehrerer Felder in einem Request.
  rpc Tokenize(TokenizeRequest) returns (TokenizeResponse);

  // Rückführung von Tokens in Klartext.
  rpc Detokenize(DetokenizeRequest) returns (DetokenizeResponse);

  // Validierung oder Analyse eines Tokens.
  rpc ValidateToken(ValidateTokenRequest) returns (ValidateTokenResponse);

  // (Optional) Verwaltung: Rotation oder Aktivierung eines neuen Schlüssels.
  rpc RotateKey(RotateKeyRequest) returns (RotateKeyResponse);

  // Hochdurchsatz-Streaming-Tokenisierung (bidirektional).
  rpc StreamTokenize(stream StreamTokenizeIn) returns (stream StreamTokenizeOut);
}
